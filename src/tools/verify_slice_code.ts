import { existsSync } from "node:fs"
import { writeFile } from "node:fs/promises"
import { basename, join as joinPath } from "node:path"

import { z } from "zod"

import { formatErrorForMcpTool } from "../lib/error"
import { tool } from "../lib/mcp"
import {
	getHasLazyLoadSlicesOption,
	readAllSliceModelsForLibrary,
} from "../lib/sliceMachine"
import type { SharedSlice } from "@prismicio/types-internal/lib/customtypes"

export const verify_slice_code = tool(
	"verify_slice_code",
	`PURPOSE: Verified that the slice code implemented compiles and that the slice is ready to be used.

USAGE: Use after implementing the slice code.

RETURNS: A message indicating whether the slice code is valid or not, with detailed errors if invalid.`,
	z.object({
		projectRoot: z
			.string()
			.describe("Absolute path to the project to generate types for"),
		sliceDirectoryAbsolutePath: z
			.string()
			.describe("Absolute path to the slice directory (contains 'model.json')"),
		projectFramework: z
			.enum(["next", "nuxt", "sveltekit"])
			.describe("Project framework (Next.js, Nuxt, or SvelteKit)"),
	}).shape,
	async (args) => {
		const {
			sliceDirectoryAbsolutePath,
			projectRoot,
			projectFramework: framework,
		} = args

		const sliceMachineConfigAbsolutePath = joinPath(
			projectRoot,
			"slicemachine.config.json",
		)

		try {
			// TODO: Tracking
		} catch (error) {
			// noop, we don't wanna block the tool call if the tracking fails
			if (process.env.PRISMIC_DEBUG) {
				console.error(
					"Error while tracking 'verify_slice_code' tool call:",
					error,
				)
			}
		}

		try {
			const sliceName = basename(sliceDirectoryAbsolutePath)

			const libraryPath = joinPath(sliceDirectoryAbsolutePath, "..")

			const slices = await readAllSliceModelsForLibrary({
				sliceMachineConfigAbsolutePath,
				projectRoot,
				libraryPath,
			})

			await writeSliceLibraryIndexFile({
				slices,
				framework,
				projectRoot,
				libraryPath,
				lazyLoad: getHasLazyLoadSlicesOption(sliceMachineConfigAbsolutePath),
			})

			return {
				content: [
					{
						type: "text",
						text: `'${sliceName}' slice is ready to be used.`,
					},
				],
			}
		} catch (error) {
			return formatErrorForMcpTool(error)
		}
	},
)

type Framework = "next" | "nuxt" | "sveltekit"

const NON_EDITABLE_FILE_BANNER =
	"// Code generated by Slice Machine. DO NOT EDIT."

async function writeSliceLibraryIndexFile(args: {
	slices: SharedSlice[]
	framework: Framework
	lazyLoad: boolean
	projectRoot: string
	libraryPath: string
}) {
	const { slices, framework, lazyLoad = true, projectRoot, libraryPath } = args

	let contents: string
	switch (framework) {
		case "next":
			{
				if (lazyLoad) {
					const dynamicImports = slices
						.map((slice) => {
							return `\t${slice.id}: dynamic(() => import('./${pascalCase(slice.name)}'))`
						})
						.join(",\n")

					contents = `${NON_EDITABLE_FILE_BANNER}

import dynamic from 'next/dynamic'

export const components = {
${dynamicImports}
}`
				} else {
					const imports = slices
						.map((slice) => {
							return `import ${pascalCase(slice.name)} from "./${slice.name}";`
						})
						.join("\n")

					const exports = slices
						.map((slice) => {
							const componentName = pascalCase(slice.name)

							return `\t${slice.id}: ${componentName},`
						})
						.join("\n")

					contents = `${NON_EDITABLE_FILE_BANNER}

${imports}

export const components = {
${exports}
}`
				}
			}
			break

		case "nuxt": {
			if (lazyLoad) {
				const asyncComponents = slices
					.map((slice) => {
						return `\t${slice.id}: defineAsyncComponent(() => import("./${slice.name}/index.vue"))`
					})
					.join(",\n")

				contents = `${NON_EDITABLE_FILE_BANNER}

import { defineAsyncComponent } from "vue";
import { defineSliceZoneComponents } from "@prismicio/vue";

export const components = defineSliceZoneComponents({
${asyncComponents}
});`
			} else {
				const imports = slices
					.map((slice) => {
						return `import ${pascalCase(slice.name)} from "./${slice.name}/index.vue";`
					})
					.join("\n")

				const exports = slices
					.map((slice) => {
						return `\t${slice.id}: ${pascalCase(slice.name)}`
					})
					.join(",\n")

				contents = `${NON_EDITABLE_FILE_BANNER}

import { defineSliceZoneComponents } from "@prismicio/vue";

${imports}

export const components = defineSliceZoneComponents({
${exports}
});`
			}
			break
		}

		case "sveltekit": {
			const imports = slices
				.map((slice) => {
					return `import ${pascalCase(slice.name)} from "./${slice.name}/index.svelte";`
				})
				.join("\n")

			const exports = slices
				.map((slice) => {
					return `\t${slice.id}: ${pascalCase(slice.name)},`
				})
				.join("\n")

			contents = `${NON_EDITABLE_FILE_BANNER}

${imports}

export const components = {
${exports}
}`
			break
		}

		default: {
			throw new Error(`Unsupported framework: ${framework}`)
		}
	}

	const filePath = `index.${existsSync(joinPath(projectRoot, "tsconfig.json")) ? "ts" : "js"}`

	return writeFile(joinPath(libraryPath, filePath), contents)
}

function pascalCase(str: string): string {
	return str
		.split(/[-_\s]+/)
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
		.join("")
}
