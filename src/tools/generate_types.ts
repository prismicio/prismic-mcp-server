import { stripIndent } from "common-tags"
import type { Dirent } from "fs"
import { existsSync } from "fs"
import { join as joinPath } from "path"
import {
	format as prettierFormat,
	resolveConfig as resolvePrettierConfig,
} from "prettier"
import { z } from "zod"

import { formatDecodeError, formatErrorForMcpTool } from "../lib/error"
import { tool } from "../lib/mcp"
import {
	CustomType,
	SharedSlice,
} from "@prismicio/types-internal/lib/customtypes"

import { telemetryClient } from "../server"
import { readFile, readdir, writeFile } from "fs/promises"

const SliceMachineConfig = z.object({ libraries: z.array(z.string()) })

const NON_EDITABLE_FILE_HEADER =
	"// Code generated by Slice Machine. DO NOT EDIT."

export const generate_types = tool(
	"generate_types",
	`PURPOSE: Generate TypeScript types from a library of Prismic models.

USAGE: Use when you need TypeScript types to match your Prismic model definitions, typically after creating or modifying a slice model to keep types in sync.

RETURNS: A success message indicating the path to the generated types file or an error message if the generation fails.`,
	z.object({
		projectRoot: z
			.string()
			.describe("Absolute path to the project to generate types for"),
	}).shape,

	async (args) => {
		const { projectRoot } = args
		const smConfigPath = joinPath(projectRoot, "slicemachine.config.json")

		try {
			if (!existsSync(smConfigPath)) {
				throw new Error(
					`Could not find 'slicemachine.config.json' in your project root (${projectRoot})`,
				)
			}

			try {
				telemetryClient.track({
					event: "MCP Tool - Generate types",
					sliceMachineConfigAbsolutePath: smConfigPath,
				})
			} catch (error) {
				// noop, we don't wanna block the tool call if the tracking fails
				if (process.env.PRISMIC_DEBUG) {
					console.error(
						"Error while tracking 'generate_types' tool call",
						error,
					)
				}
			}

			// Dynamic import to handle Node.js 18 CommonJS/ESM interop issues with prismic-ts-codegen
			// TODO: Fix this issue in prismic-ts-codegen: https://linear.app/prismic/issue/DT-2886
			const { detectTypesProvider, generateTypes } = await import(
				"prismic-ts-codegen"
			)

			// Read custom type models

			const customTypeModels: CustomType[] = []

			try {
				const ctLibraryPath = joinPath(projectRoot, "customtypes")
				const ctPaths = await readdir(ctLibraryPath)

				await Promise.all(
					ctPaths.map(async (ctPath) => {
						const customTypeDirPath = joinPath(ctLibraryPath, ctPath)

						if ((await readdir(customTypeDirPath)).length === 0) {
							// if directory is empty, skip, not need to fails because of this
							return
						}

						const modelPath = joinPath(customTypeDirPath, "index.json")

						let modelContents: unknown
						try {
							modelContents = JSON.parse(await readFile(modelPath, "utf8"))
						} catch (error) {
							throw new Error(
								`Invalid JSON format for custom type model at ${modelPath}: ${getErrorMessage(error)}`,
							)
						}

						const parsedModel = CustomType.decode(modelContents)
						if (parsedModel._tag === "Left") {
							const errors = parsedModel.left.map(formatDecodeError).join("\n")
							throw new Error(
								`Invalid custom type model at ${modelPath}:\n${errors}`,
							)
						}

						customTypeModels.push(parsedModel.right)
					}),
				)
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Failed to read custom type models.

Encountered errors:
${getErrorMessage(error)}
							
SUGGESTION: Fix the errors mentioned above before generating the types. If you're unsure about custom type modeling, you need to learn how to model a Prismic custom type first.`,
						},
					],
				}
			}

			// Read shared slice models

			const sharedSliceModels: SharedSlice[] = []

			try {
				const sliceLibraryPaths = SliceMachineConfig.parse(
					JSON.parse(await readFile(smConfigPath, "utf8")),
				).libraries

				await Promise.all(
					sliceLibraryPaths.map(async (relativeLibraryPath) => {
						const libraryPath = joinPath(projectRoot, relativeLibraryPath)

						let slicePaths: Dirent[] = []
						try {
							slicePaths = await readdir(libraryPath, { withFileTypes: true })
						} catch (error) {
							throw new Error(
								`Failed to read slice library at ${libraryPath}: ${getErrorMessage(error)}`,
							)
						}

						await Promise.all(
							slicePaths.map(async (slicePath) => {
								if (!slicePath.isDirectory()) {
									return
								}

								const sliceDirPath = joinPath(libraryPath, slicePath.name)
								if ((await readdir(sliceDirPath)).length === 0) {
									// if directory is empty, skip, not need to fails because of this
									return
								}

								const modelPath = joinPath(sliceDirPath, "model.json")

								let modelContents: unknown
								try {
									modelContents = JSON.parse(await readFile(modelPath, "utf8"))
								} catch (error) {
									throw new Error(
										`Invalid JSON format for slice model at ${modelPath}: ${getErrorMessage(error)}`,
									)
								}

								const parsedModel = SharedSlice.decode(modelContents)
								if (parsedModel._tag === "Left") {
									throw new Error(
										`Invalid slice model at ${modelPath}. Please use the 'verify_slice_model' tool to validate the model before generating the types.`,
									)
								}

								sharedSliceModels.push(parsedModel.right)
							}),
						)
					}),
				)
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Failed to read slice models.

Encountered errors:
${getErrorMessage(error)}
							
SUGGESTION: Fix the errors mentioned above before generating the types. If you're unsure about custom type modeling, you need to learn how to model a Prismic slice first.`,
						},
					],
				}
			}

			// Generate types definitions

			let typeDefinitions = generateTypes({
				customTypeModels,
				sharedSliceModels,
				clientIntegration: {
					includeCreateClientInterface: true,
					includeContentNamespace: true,
				},
				typesProvider: await detectTypesProvider({ cwd: projectRoot }),
			})
			typeDefinitions = `${NON_EDITABLE_FILE_HEADER}\n\n${typeDefinitions}`

			// Format file content

			const typesFilePath = joinPath(projectRoot, "prismicio-types.d.ts")

			let formattedTypes = stripIndent(typeDefinitions)
			const prettierOptions = await resolvePrettierConfig(projectRoot)
			formattedTypes = await prettierFormat(formattedTypes, {
				...prettierOptions,
				filepath: typesFilePath,
			})
			formattedTypes = formattedTypes.replace(/[\r\n]+$/, "")

			// Write types definitions file

			await writeFile(typesFilePath, formattedTypes)

			return {
				content: [
					{
						type: "text",
						text: `Type definitions generated successfully at ${typesFilePath}`,
					},
				],
			}
		} catch (error) {
			return formatErrorForMcpTool(error)
		}
	},
)

function getErrorMessage(error: unknown): string {
	return error instanceof Error ? error.message : String(error)
}
